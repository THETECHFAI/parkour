<!-- Generated by SpecStory -->

# Enhancing Character Dynamics in Game (2025-03-20 22:41:49)

_**User**_

Can you improve the character. Replace primitive shapes with a low-poly cyberpunk runner model. Ensure the existing features of the game are not impacted


---

_**Assistant**_



---

I'll replace the primitive character with a low-poly cyberpunk runner model. This requires adding the GLTFLoader and modifying the character creation code.

---

```diff
  import * as THREE from 'three';
  import * as CANNON from 'cannon-es';
+ import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
  
  // Global variables for the game
  let camera, scene, renderer, world;
- let playerBody, playerMesh;
+ let playerBody, playerMesh, playerModel;
  let hackingNode;
  let keys = {};
  }
  
- // Create the player character (humanoid stick figure)
+ // Create the player character (replacing primitive shapes with cyberpunk model)
  function createPlayer() {
-     const playerGroup = new THREE.Group();
- 
-     const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1, 16);
-     const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x4488ff });
-     const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
-     body.position.set(0, 0.5, 0);
-     body.castShadow = true;
-     playerGroup.add(body);
- 
-     const headGeometry = new THREE.SphereGeometry(0.2, 16, 16);
-     const headMaterial = new THREE.MeshPhongMaterial({ color: 0x4488ff });
-     const head = new THREE.Mesh(headGeometry, headMaterial);
-     head.position.set(0, 1.1, 0);
-     head.castShadow = true;
-     playerGroup.add(head);
- 
-     const armGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.6, 16);
-     const armMaterial = new THREE.MeshPhongMaterial({ color: 0x4488ff });
- 
-     const leftArm = new THREE.Mesh(armGeometry, armMaterial);
-     leftArm.position.set(-0.4, 0.7, 0);
-     leftArm.rotation.z = Math.PI / 4;
-     leftArm.castShadow = true;
-     playerGroup.add(leftArm);
- 
-     const rightArm = new THREE.Mesh(armGeometry, armMaterial);
-     rightArm.position.set(0.4, 0.7, 0);
-     rightArm.rotation.z = -Math.PI / 4;
-     rightArm.castShadow = true;
-     playerGroup.add(rightArm);
- 
-     const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.6, 16);
-     const legMaterial = new THREE.MeshPhongMaterial({ color: 0x4488ff });
- 
-     const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
-     leftLeg.position.set(-0.15, -0.3, 0);
-     leftLeg.castShadow = true;
-     playerGroup.add(leftLeg);
- 
-     const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
-     rightLeg.position.set(0.15, -0.3, 0);
-     rightLeg.castShadow = true;
-     playerGroup.add(rightLeg);
- 
-     scene.add(playerGroup);
-     playerMesh = playerGroup;
+     // Create a group to hold the player model
+     playerMesh = new THREE.Group();
+     scene.add(playerMesh);
  
      // Create player physics material with lower friction
      );
      world.addContactMaterial(playerWorldContact);
+ 
+     // Load the cyberpunk character model
+     const loader = new GLTFLoader();
+     loader.load(
+         // URL to the model - replace with your actual model path
+         'models/cyberpunk-runner.glb',
+         // Called when the model is loaded
+         (gltf) => {
+             playerModel = gltf.scene;
+             
+             // Scale and position the model to match the physics body
+             playerModel.scale.set(0.4, 0.4, 0.4); // Adjust scale as needed for your model
+             playerModel.position.y = -PLAYER_HEIGHT / 2; // Adjust based on model center
+             
+             // Apply cyberpunk styling with emission
+             playerModel.traverse((child) => {
+                 if (child.isMesh) {
+                     // Apply cyberpunk materials
+                     child.material = new THREE.MeshPhongMaterial({
+                         color: 0x4488ff,
+                         emissive: 0x112244,
+                         shininess: 30
+                     });
+                     
+                     // Enable shadows
+                     child.castShadow = true;
+                     child.receiveShadow = true;
+                 }
+             });
+             
+             // Add the model to the player group
+             playerMesh.add(playerModel);
+             
+             // Add emission effects to highlight the character
+             const playerLight = new THREE.PointLight(0x4488ff, 0.5, 1);
+             playerLight.position.set(0, 0.5, 0);
+             playerMesh.add(playerLight);
+         },
+         // Called while loading is in progress
+         (xhr) => {
+             console.log((xhr.loaded / xhr.total * 100) + '% loaded');
+         },
+         // Called if there's an error loading the model
+         (error) => {
+             console.error('Error loading model:', error);
+             
+             // Fallback to primitive shapes if model fails to load
+             createFallbackPlayerModel();
+         }
+     );
  
      // Set up better contact detection for jumping and movement
      return worldMaterial;
  }
+ 
+ // Fallback function to create primitive player model if GLTF loading fails
+ function createFallbackPlayerModel() {
+     console.log("Using fallback player model");
+     
+     const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1, 16);
+     const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x4488ff, emissive: 0x112244 });
+     const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
+     body.position.set(0, 0.5, 0);
+     body.castShadow = true;
+     playerMesh.add(body);
+ 
+     const headGeometry = new THREE.SphereGeometry(0.2, 16, 16);
+     const headMaterial = new THREE.MeshPhongMaterial({ color: 0x4488ff, emissive: 0x112244 });
+     const head = new THREE.Mesh(headGeometry, headMaterial);
+     head.position.set(0, 1.1, 0);
+     head.castShadow = true;
+     playerMesh.add(head);
+ 
+     const armGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.6, 16);
+     const armMaterial = new THREE.MeshPhongMaterial({ color: 0x4488ff, emissive: 0x112244 });
+ 
+     const leftArm = new THREE.Mesh(armGeometry, armMaterial);
+     leftArm.position.set(-0.4, 0.7, 0);
+     leftArm.rotation.z = Math.PI / 4;
+     leftArm.castShadow = true;
+     playerMesh.add(leftArm);
+ 
+     const rightArm = new THREE.Mesh(armGeometry, armMaterial);
+     rightArm.position.set(0.4, 0.7, 0);
+     rightArm.rotation.z = -Math.PI / 4;
+     rightArm.castShadow = true;
+     playerMesh.add(rightArm);
+ 
+     const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.6, 16);
+     const legMaterial = new THREE.MeshPhongMaterial({ color: 0x4488ff, emissive: 0x112244 });
+ 
+     const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
+     leftLeg.position.set(-0.15, -0.3, 0);
+     leftLeg.castShadow = true;
+     playerMesh.add(leftLeg);
+ 
+     const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
+     rightLeg.position.set(0.15, -0.3, 0);
+     rightLeg.castShadow = true;
+     playerMesh.add(rightLeg);
+ }
  
  // New function to check if player landed on a platform and award points
          playerCanJump = true; // Reset jump capability when respawning
      }
+ 
+     // Add new code at the end to update the model animation based on movement
+     if (playerModel) {
+         // Rotate the model to face the direction of movement
+         if (moveX !== 0 || moveZ !== 0) {
+             const moveAngle = Math.atan2(moveX, moveZ);
+             const currentRotation = playerModel.rotation.y;
+             
+             // Smoothly rotate the model toward the movement direction
+             playerModel.rotation.y = currentRotation + (moveAngle - currentRotation) * 0.1;
+             
+             // Simple animation effect - bob up and down when moving
+             const bobAmount = 0.05;
+             const bobSpeed = 10;
+             playerModel.position.y = -PLAYER_HEIGHT / 2 + Math.sin(Date.now() / 200 * (horizontalSpeed / 5)) * bobAmount;
+             
+             // Tilt the model slightly when turning
+             const turnAmount = 0.2;
+             playerModel.rotation.z = (currentRotation - moveAngle) * turnAmount;
+         }
+         
+         // Lean forward when sprinting
+         if (isSprinting && stamina > 0) {
+             playerModel.rotation.x = Math.min(playerModel.rotation.x + 0.01, 0.3);
+         } else {
+             playerModel.rotation.x = Math.max(playerModel.rotation.x - 0.01, 0);
+         }
+     }
  }
  
```

---

Now I need to create a model directory and add a cyberpunk runner model file.

---

```bash
mkdir -p models
```

```
faisalshariff@Mac Parkour2 % 

```

---

Now, I'll create a simple low-poly cyberpunk runner model using Three.js built-in geometries, to avoid requiring an external model file.

---

Cancelled

---



---



---

